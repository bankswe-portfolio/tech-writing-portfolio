{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Technical Writing Portfolio","text":"<p>Welcome \u2014 thanks for visiting.</p> <p>This portfolio collects case studies that demonstrate my approach to technical writing. Each piece was created either as part of a job application exercise or as an independent project to showcase how I handle developer-facing documentation.  </p> <p>Across the Case Studies, you\u2019ll see how I:</p> <ul> <li>Translate complex tools into clear, scenario-driven guidance  </li> <li>Balance technical depth with accessibility for different audiences  </li> <li>Treat documentation as part of the product experience, not an afterthought  </li> </ul> <p>The goal is to show both how I write and why I make the choices I do \u2014 clarity, usability, and context always at the center.</p>"},{"location":"#about-me","title":"About Me","text":"<p>I\u2019m Will Banks, a technical writer and former research engineer with 10+ years of experience translating complex systems into clear, actionable content. My background spans developer SDKs, APIs, avionics standards, and biomedical platforms \u2014 all unified by one theme: making technical knowledge approachable and useful.</p> <p>I specialize in docs-as-code workflows (AsciiDoc, Markdown, MkDocs, CI/CD pipelines), developer-focused documentation (SDK guides, API references, conceptual explainers), and technical storytelling that connects product features to real-world outcomes.</p> <p>Before pivoting full-time into documentation, I worked on projects ranging from U.S. Navy defense systems to FACE-conformant avionics platforms and Unity-based neuroscience tools. Along the way, I\u2019ve authored comprehensive developer guides, built automated doc pipelines, presented at technical summits, and contributed to peer-reviewed publications.</p> <p>What drives me is clarity: giving engineers, developers, and product teams the confidence to adopt and extend complex technology.</p> <p>Connect with me on LinkedIn for my full background, or check out my Resume</p>"},{"location":"#skills-tools","title":"Skills &amp; Tools","text":"<ul> <li>Tech Writing: CLI &amp; repo workflows, docs-as-code (AsciiDoc, Markdown, PlantUML, Graphviz, OpenAPI, Postman, static site generators like MkDocs and docToolchain), AI-driven workflows</li> <li>Programming &amp; Scripting: Python, C++, Bash, JSON, YAML, Workflow Automation; IDEs including VS Code and IntelliJ IDEA </li> <li>Agile Tools: Jira, Confluence, Git, Teams, Zoom  </li> <li>Operating Systems: Windows &amp; Linux (WSL)  </li> </ul>"},{"location":"#highlights","title":"Highlights","text":"<ul> <li>Authored the FACE Technical Starter Kit Developer\u2019s Guide, distributed across the avionics industry.  </li> <li>Built automated pipelines and docs-as-code workflows from scratch.  </li> <li>Presented product development and documentation at the MOSA Summit and Vanderbilt symposia.  </li> <li>Contributed to multiple peer-reviewed publications across physics and biomedical research.  </li> </ul>"},{"location":"#case-studies-documentation-in-action","title":"Case Studies: Documentation in Action","text":"<p>Each case study demonstrates how I tackle a specific documentation challenge \u2014 whether creating new material, editing existing content, or balancing conceptual depth with practical guidance.</p> <p>Explore the Case Studies \u2192</p>"},{"location":"#lets-connect","title":"Let\u2019s Connect","text":"<p>I\u2019m currently looking for technical writing roles in SaaS, Cybersecurity, AI and other tech fields.  </p> <p>Reach me at your.email@example.com or on LinkedIn.  </p>"},{"location":"about/about/","title":"About the Portfolio","text":"<p>This portfolio serves two purposes: it showcases my writing samples and demonstrates the workflow I use to build and ship documentation.  </p> <p>The site runs on MkDocs with the Material for MkDocs theme and is deployed through GitHub Pages.  All content is written in Markdown, tracked in Git, and published automatically.  Updates follow the same pipeline used on a product team: commits, pull requests, reviews, and continuous deployment.  </p>"},{"location":"case-studies/cnquery-practical-guide_mkdocs/","title":"Getting Started with cnquery: A Practical Guide","text":""},{"location":"case-studies/cnquery-practical-guide_mkdocs/#getting-started-with-cnquery-a-practical-guide_1","title":"Getting Started with cnquery: A Practical Guide","text":"<p>About This Writing Sample</p> <p>This is not official Mondoo documentation.</p> <p>I created this guide as part of a job application to demonstrate my approach to developer-facing documentation. I chose <code>cnquery</code>, an open-source tool from Mondoo, because it is publicly available, technically rich, and well suited for showing how I translate complex material into clear, scenario-driven guidance.</p> <p>Starting from Mondoo\u2019s official cnquery documentation, I reworked the material into a Practical Guide that emphasizes:</p> <ul> <li>Scenario-based workflows (e.g., checking certificate expiry to prevent downtime)  </li> <li>Explanatory bridges linking technical steps to developer and security outcomes  </li> <li>Consistent structure and readability with clear headings, examples, and outputs  </li> <li>Forward-looking context connecting standalone use to broader security practices  </li> </ul> <p>This guide reflects my documentation philosophy:</p> <ul> <li>Clarity and depth over bare reference  </li> <li>Resources that support both hands-on adoption and higher-level understanding </li> <li>Structure that works for newcomers while rewarding experienced users  </li> <li>Content that feels like part of the product experience, not an afterthought</li> </ul>"},{"location":"case-studies/cnquery-practical-guide_mkdocs/#getting-started-with-cnquery-a-guided-introduction","title":"Getting Started with cnquery: A Guided Introduction","text":"<p>What if your systems could answer your questions directly? </p> <p>Forget juggling scripts or scrolling through endless logs.  cnquery lets you ask your infrastructure plain questions \u2014 and get clear answers, instantly. It\u2019s part of Mondoo\u2019s mission to make security actionable, approachable, and trustworthy.</p> <p>Who this is for</p> <p>New to Mondoo or cnquery.  Comfortable with a terminal. Want fast, confident answers without reading a full reference.</p> <p>In 10 minutes you\u2019ll:</p> <ul> <li>Install cnquery</li> <li>Run 3 practical queries (OS, TLS expiry, privileged users)</li> <li>Know when to use cnquery vs cnspec</li> <li>See how this scales into the Mondoo Platform</li> </ul>"},{"location":"case-studies/cnquery-practical-guide_mkdocs/#1-what-is-cnquery","title":"1) What is cnquery?","text":"<p>At its core, cnquery is an open source, cloud-native command-line tool powered by MQL (Mondoo Query Language).  It integrates with hundreds of resources so you can ask direct questions about cloud, OS, SaaS, containers, and more.  When you run a query, you point cnquery at a target.  Targets can be your local machine, a remote host over SSH/WinRM, a website for TLS checks, a cloud account, a container, and more. </p> <p>Why this matters</p> <p>Most of us cobble together scripts, grep, and half-remembered commands when problems hit. cnquery gives you one consistent way to interrogate your systems \u2014 without guesswork.</p>"},{"location":"case-studies/cnquery-practical-guide_mkdocs/#2-install-cnquery","title":"2) Install cnquery","text":"<p>Installation scripts come directly from Mondoo\u2019s distribution.  In most environments they can be run as-is; for stricter environments see Provider Management.</p> <p>Linux &amp; macOS (curl script):</p> <pre><code>bash -c \"$(curl -sSL https://install.mondoo.com/sh)\"\n</code></pre> <p>Windows (PowerShell):</p> <pre><code>Set-ExecutionPolicy Unrestricted -Scope Process -Force\n[System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072\niex ((New-Object System.Net.WebClient).DownloadString('https://install.mondoo.com/ps1/cnquery'))\nInstall-Mondoo -Product cnquery\n</code></pre> <p>Verify installation:</p> <pre><code>cnquery version\n</code></pre> <p>Expected output:</p> <pre><code>cnquery vX.Y.Z #e.g. v8.3.0\n</code></pre>"},{"location":"case-studies/cnquery-practical-guide_mkdocs/#3-your-first-queries","title":"3) Your first queries","text":"<p>You can run one-off queries or use the interactive shell.  One-off mode is perfect for quick checks you might script into automation, while the interactive shell is best for exploring resources and learning the language.</p> <p>In these examples we use the local target (your current machine). Other common targets include <code>ssh user@host</code>, <code>host mondoo.com</code>, <code>docker</code>, <code>k8s</code>, and cloud providers like <code>aws</code>.</p> <p>Common Targets</p> <ul> <li><code>local</code> \u2192 your current machine</li> <li><code>ssh user@host</code> \u2192 remote Linux/Windows hosts</li> <li><code>host &lt;domain&gt;</code> \u2192 websites (for TLS checks)</li> <li><code>docker</code>, <code>k8s</code> \u2192 containers and clusters</li> <li><code>aws</code>, <code>gcp</code>, <code>azure</code> \u2192 cloud accounts</li> </ul> <p>See full list in Supported Query Targets.</p> <p>Option A \u2014 one-off:</p> <pre><code>cnquery run local -c \"os.name\"\n</code></pre> <p>Option B \u2014 shell (recommended for exploring):</p> <pre><code>cnquery shell local\nhelp os\n</code></pre> <p>Then run queries like <code>os.name</code>.</p> <p>Why this matters</p> <p>cnquery gives you two ways to work: fast one-off commands that you can drop into scripts, or a dedicated shell for exploration.  This flexibility means you can start small and scale up as your needs grow, without changing tools.</p>"},{"location":"case-studies/cnquery-practical-guide_mkdocs/#example-1-what-os-am-i-running","title":"Example 1 \u2014 \u201cWhat OS am I running?\u201d","text":"<pre><code>cnquery run local -c \"os.name\"\n</code></pre> <p>Output (example):</p> <pre><code>Ubuntu\n</code></pre> <p><code>os.name</code> is provided by the OS pack.</p> <p>Why this matters</p> <p>Sometimes the simplest question is the most important.  Whether you\u2019re jumping between development, staging, and production machines or auditing servers you haven\u2019t touched in months, this query gives you a consistent way to confirm exactly what system you\u2019re on.  No need to recall which platform uses <code>uname</code> or <code>lsb_release</code> \u2014 cnquery provides one universal approach.</p>"},{"location":"case-studies/cnquery-practical-guide_mkdocs/#example-2-are-my-tls-certs-about-to-expire","title":"Example 2 \u2014 \u201cAre my TLS certs about to expire?\u201d","text":"<p>Check a public host\u2019s certificates (30-day horizon):</p> <pre><code>cnquery shell host mondoo.com\ntls.certificates.where(notAfter - time.now &lt; 30 * time.day) { subject.dn issuer.dn notAfter }\n</code></pre> <ul> <li><code>host mondoo.com</code> targets a website (SSL/TLS).  </li> <li><code>notAfter</code> is the certificate expiry field; we compare it with <code>time.now</code>.</li> </ul> <p>Why this matters</p> <p>Few issues cause more disruption than an expired TLS certificate.  Customers see a browser warning, trust drops, and your team is forced into emergency response.  This query helps you stay ahead by flagging certificates that are close to expiring, giving you time to renew.</p>"},{"location":"case-studies/cnquery-practical-guide_mkdocs/#example-3-who-has-sudo-access","title":"Example 3 \u2014 \u201cWho has sudo access?\u201d","text":"<p>On many Linux distros, privileged users belong to the <code>sudo</code> group:</p> <pre><code>cnquery run local -c 'group(\"sudo\") { members { name } }'\n</code></pre> <p>This directly queries the <code>group</code> resource, then lists its <code>members</code>. Swap <code>sudo \u2192 wheel</code> (RHEL/Fedora) or <code>Administrators</code> (Windows).</p> <p>Why this matters</p> <p>Privilege management is a foundation of security.  A single unexpected user with administrator rights can open the door to major risk.  This query gives you immediate visibility into who holds elevated access, so you can validate against your intended policy without manual parsing.</p>"},{"location":"case-studies/cnquery-practical-guide_mkdocs/#4-real-world-scenario-responding-to-a-cve","title":"4) Real-world scenario: Responding to a CVE","text":"<p>A CVE affecting <code>openssl</code> just dropped. Find impacted hosts fast:</p> <pre><code>cnquery run local -c \"packages.where(name == 'openssl') { name version }\"\n</code></pre> <p><code>packages</code> is the list of OS packages. Each <code>package</code> contains fields like <code>name</code> and <code>version</code>.</p> <p>Why this matters</p> <p>When a new vulnerability is announced, speed matters.  You need to know immediately which of your systems are running affected versions.  cnquery lets you search installed packages in seconds, giving you clear visibility and the confidence to prioritize patching quickly \u2014 without assembling ad-hoc scripts under pressure.</p>"},{"location":"case-studies/cnquery-practical-guide_mkdocs/#5-where-cnquery-fits-with-the-mondoo-platform","title":"5) Where cnquery fits with the Mondoo Platform","text":"<p>By itself, cnquery gives you instant answers.  But its real power is as a springboard into automation:</p> <ul> <li>Feed results into cnspec for repeatable compliance checks  </li> <li>Pipe data into the Mondoo Platform to visualize risks across fleets  </li> <li>Turn one-off discoveries (like that expiring cert) into policies that prevent recurrence</li> </ul> <p>Why this matters</p> <p>cnquery is more than a standalone tool \u2014 it\u2019s the entry point into Mondoo\u2019s larger ecosystem. The same queries you run today can evolve into policies, dashboards, and automated workflows tomorrow. You gain immediate visibility while building toward scalable, repeatable security practices.</p>"},{"location":"case-studies/cnquery-practical-guide_mkdocs/#6-faq","title":"6) FAQ","text":"<p>When should I use <code>cnquery</code> vs <code>cnspec</code>?</p> <p>Use cnquery to ask questions and explore with ad\u2011hoc MQL.  Use cnspec when you want repeatable policy checks (benchmarks, remediations, CI/CD gates).  See examples throughout the cnspec docs</p> <p>Do I need to specify a \u201ctarget\u201d?</p> <p>Yes.  Common ones are <code>local</code>, <code>ssh user@host</code>, <code>host &lt;domain&gt;</code>, cloud providers like <code>aws</code>, and many more\u2014see the Supported Query Targets page for examples.  See the full list in Supported Query Targets.</p> <p>Is cnquery safe in production?</p> <p>cnquery queries configuration/state; it doesn\u2019t alter your workloads.  It may write provider plugins unless you disable auto\u2011update; for strict read\u2011only environments, pre\u2011install providers and turn off provider auto\u2011update.</p>"},{"location":"case-studies/cnquery-practical-guide_mkdocs/#7-where-to-go-next","title":"7) Where to go next","text":"<ul> <li>Learn MQL basics and write effective MQL.</li> <li>Explore Query Your Infrastructure and the MQL Resource Reference.</li> <li>When you\u2019re ready for policy\u2011as\u2011code and continuous assessment, move to cnspec and the Mondoo Platform.</li> </ul>"},{"location":"case-studies/horizon3ai-tripwires-redline/","title":"Horizon3.ai - NodeZero Tripwires Redline","text":"<p>About This Writing Sample</p> <p>This is not official Horizon3.ai documentation.</p> <p>I created this editorial redline as part of a Horizon3.ai job application exercise. The assignment was to review an existing documentation page (NodeZero Tripwires) and provide clear, actionable edits that improve clarity, structure, and consistency\u2014without rewriting from scratch.</p> <p>\ud83d\udc49 View the redlined document in Google Docs</p>"},{"location":"case-studies/horizon3ai-tripwires-redline/#my-editorial-approach","title":"My Editorial Approach","text":"<p>I evaluated the Tripwires documentation at both the macro level (overall structure, flow, and navigation) and the micro level (style, consistency, and tone). Some of the key areas I addressed:</p> <ul> <li>Structure &amp; Navigation: Break long lists into tabs/accordions, add troubleshooting anchors, and introduce flowcharts  </li> <li>Consistency: Standardize admonitions, hyperlink style, and UI element formatting  </li> <li>Voice &amp; Style: Shift to active voice, resolve sentence fragments, and align terminology with branding  </li> <li>Audience: Reduce jargon, make prerequisites explicit, and emphasize actionable instructions  </li> </ul> <p>This exercise demonstrates my ability to:</p> <ul> <li>Critically evaluate existing documentation  </li> <li>Apply consistent editorial standards  </li> <li>Enhance usability while preserving technical accuracy</li> </ul>"},{"location":"case-studies/longchain-chains-vs-agents/","title":"Chains vs. Agents in LangChain","text":"<p>About This Writing Sample</p> <p>This is not official LangChain documentation.</p> <p>I created this guide independently as part of my portfolio to illustrate how I explain complex developer concepts. I chose the topic Chains vs. Agents because it sits at the core of LangChain\u2019s design philosophy, yet is often a source of confusion for new users.</p> <p>All claims and definitions are aligned with the latest LangChain &amp; LangGraph docs (v0.2). References: LangChain Introduction | Concepts: Agents | LangGraph: Why LangGraph | LangSmith Docs</p>"},{"location":"case-studies/longchain-chains-vs-agents/#welcome-why-you-should-care","title":"Welcome: Why You Should Care","text":"<p>If you\u2019re new to LangChain, you\u2019ve probably run into two terms right away: Chain and Agent.  Both are central concepts, and both are powerful \u2014 but they serve different purposes.</p> <p>Why does this matter? </p> <ul> <li>Using a Chain where you actually need an Agent can leave you with workflows that feel rigid and difficult to adapt.  </li> <li>Using an Agent where a Chain would suffice can lead to unnecessary overhead: slower runs, higher API costs, and trickier debugging.  </li> </ul> <p>Developers often encounter these pain points firsthand:  </p> <ul> <li>Chains that break because they can\u2019t handle a new condition.  </li> <li>Agents that wander off-course, loop endlessly, or generate a surprising number of tool calls.  </li> </ul> <p>This guide gives you the mental model you need \u2014 no prior LangChain experience required.  By the end, you\u2019ll understand:</p> <ul> <li>What a Chain is (and why it\u2019s like following a recipe).  </li> <li>What an Agent is (and why it\u2019s like a chef improvising in the kitchen).  </li> <li>How to decide between them for your project.  </li> <li>Common pitfalls and best practices.  </li> <li>How they fit into the broader LangChain ecosystem: LangGraph (for controllable, stateful agents and workflows) and LangSmith (for tracing, evaluating, and monitoring).</li> </ul> <p>In the sections that follow, we\u2019ll compare Chains and Agents side by side, highlight use cases, share diagrams, and show how these concepts connect to the modern LangChain stack.</p>"},{"location":"case-studies/longchain-chains-vs-agents/#chains-vs-agents-picture-it","title":"Chains vs. Agents: Picture It","text":"<p>Before diving into details, here\u2019s the high-level contrast.  Chains and Agents are both ways of structuring work with an LLM \u2014 but they think differently about control.</p> <pre><code>graph LR\n    I[Input] --&gt; S1[Step 1]\n    S1 --&gt; S2[Step 2]\n    S2 --&gt; SN[... Step n]\n    SN --&gt; O[Output]</code></pre> <p>Figure 1: A Chain is a fixed pipeline. </p> <p>Input flows through predefined steps you design in advance, producing a predictable output.</p> <pre><code>graph TD\n    U[User Task] --&gt; C((LLM Controller))\n    C --&gt; T1[Tool A]\n    C --&gt; T2[Tool B]\n    C --&gt; T3[Tool C]\n    T1 --&gt; O1[Observation]\n    T2 --&gt; O2[Observation]\n    T3 --&gt; O3[Observation]\n    O1 --&gt; C\n    O2 --&gt; C\n    O3 --&gt; C\n    C --&gt; OUT[Final Answer]</code></pre> <p>Figure 2: An Agent is an improviser. </p> <p>The LLM chooses tools at runtime, reasons over observations, and iterates until it can deliver an answer.</p>"},{"location":"case-studies/longchain-chains-vs-agents/#chains-the-recipe-approach","title":"Chains: The \u201cRecipe\u201d Approach","text":""},{"location":"case-studies/longchain-chains-vs-agents/#what-it-feels-like","title":"What it feels like","text":"<ul> <li>You wire together components (prompting, retrieval, parsing, post-processing).  </li> <li>The flow is predictable and repeatable (easier to debug, easier to test).  </li> <li>Ideal for document pipelines, summarization, and data transforms.  </li> </ul> <p>Realistic use case: </p> <p>A support team wants daily digests of customer tickets.  A Chain can summarize each ticket, extract key issues, and compile them into a single report.</p> <p>When to use Chains</p> <p>Use a Chain when your steps are known in advance and you want predictability. Think repeatable workflows: ETL, summarization, and document processing.</p>"},{"location":"case-studies/longchain-chains-vs-agents/#agents-the-improviser","title":"Agents: The \u201cImproviser\u201d","text":"<p>An Agent is a system that uses an LLM to decide what to do next.  Instead of you hard-coding each step, the model chooses which tools or actions to run at runtime based on the task and observed tool outputs.</p>"},{"location":"case-studies/longchain-chains-vs-agents/#what-it-feels-like_1","title":"What it feels like","text":"<ul> <li>You define tools (web search, math, database lookups, APIs).  </li> <li>The LLM is the controller that decides which tool to use, in what order.  </li> <li>Ideal for interactive research assistants, multi-tool orchestration, or tasks where the path isn\u2019t clear upfront.  </li> </ul> <p>Realistic use case: </p> <p>A research assistant that decides when to search the web, when to use a calculator, and when to summarize findings \u2014 depending on the query.</p> <p>Modern guidance: </p> <p>LangChain explicitly recommends building agents with LangGraph for control, reliability, and production readiness.  Legacy <code>AgentExecutor</code> is being phased out.</p> <p>When to use Agents</p> <p>Use an Agent when you need dynamic tool use and the steps can\u2019t be pre-defined. Expect more variability and overhead, and plan on adding observability (LangSmith) and guardrails.</p>"},{"location":"case-studies/longchain-chains-vs-agents/#side-by-side-chains-vs-agents","title":"Side-by-Side: Chains vs. Agents","text":"Aspect Chains (Recipe) Agents (Improviser) Flow Fixed, pre-defined sequence Dynamic; LLM chooses tools/steps at runtime Predictability High (repeatable, testable) Lower (varies with inputs, tool outcomes, model decisions) Use cases Summarization pipelines, ETL/data transforms Research assistants, tool orchestration, conditional flows Debugging Easier: clear steps Harder: LLM\u2019s choices + external tools Performance/Cost Lower latency, more efficient Higher overhead, longer latency"},{"location":"case-studies/longchain-chains-vs-agents/#decision-helper","title":"Decision Helper","text":"<pre><code>graph TD\n    Q{\"Do you know the steps ahead of time?\"}\n    Q --&gt;|Yes| C[\"Use a Chain\"]\n    Q --&gt;|No| A[\"Use an Agent (via LangGraph)\"]</code></pre> <p>Figure 3: If you know the steps ahead of time, use a Chain.</p> <p>If not, use an Agent \u2014 and for production, build it with LangGraph for controllability and persistence.</p>"},{"location":"case-studies/longchain-chains-vs-agents/#common-pitfalls","title":"Common Pitfalls","text":"Paradigm Pitfall Fix Chains Brittle if a step expects perfectly formatted input Validate and normalize inputs early; keep steps small and composable Agents LLM chooses the wrong tool or loops Limit toolset initially, set iteration/time limits, and add observability <p>Comfort check: </p> <p>It\u2019s normal if your first Agent feels chaotic.  Start small, grow toolsets gradually, and trace runs to understand decisions.</p>"},{"location":"case-studies/longchain-chains-vs-agents/#best-practices","title":"Best Practices","text":"<ul> <li>Start simple: Begin with Chains; graduate to Agents only when necessary.  </li> <li>Keep it modular: Break big tasks into smaller Chains, then combine.  </li> <li>Limit toolsets: The fewer tools an Agent can choose from, the more reliable it is.  </li> <li>Trace everything: Use LangSmith to see what\u2019s happening under the hood.  </li> <li>Plan for control: Use LangGraph to structure Agents for production.  </li> </ul>"},{"location":"case-studies/longchain-chains-vs-agents/#where-chains-agents-fit-in-the-langchain-ecosystem","title":"Where Chains &amp; Agents Fit in the LangChain Ecosystem","text":"<pre><code>graph TB\n    A[\"LangChain: Building blocks (models, retrievers, tools)\"] --&gt; B[\"LangGraph: Orchestration(stateful agents, workflows)\"]\n    B --&gt; C[\"LangSmith: Observability (tracing, evaluation, monitoring)\"]</code></pre> <ul> <li>LangChain gives you the components and mental model.  </li> <li>LangGraph is the recommended framework for building controllable, stateful agents and workflows.  </li> <li>LangSmith is the observability + evaluation layer to trace, measure, and ship with confidence.  </li> </ul> <p>Together, they form the modern LangChain stack: build, orchestrate, observe.</p>"},{"location":"case-studies/longchain-chains-vs-agents/#wrap-up-next-steps","title":"Wrap-Up &amp; Next Steps","text":"<p>You now have the mental model:</p> <ul> <li>Chains = the predictable recipe.  </li> <li>Agents = the improviser that picks tools dynamically (best built with LangGraph today).  </li> </ul> <p>Try this yourself:</p> <ol> <li>Build a Chain that summarizes a paragraph and extracts two facts.  </li> <li>Build an Agent that can either search the web or do simple math.     Trace the run in LangSmith to watch its decisions.  </li> </ol> <p>By now, Chains vs. Agents should feel less like jargon and more like clear tools in your kit.  You\u2019re ready to choose the right one with confidence\u2014and you\u2019ve got the ecosystem pieces (LangGraph + LangSmith) to grow from demo to production.</p> <p>\ud83d\udc4f That\u2019s it! You\u2019re ready to put Chains and Agents to work.</p>"},{"location":"case-studies/longchain-chains-vs-agents/#resources","title":"Resources","text":"<ul> <li>LangChain Introduction </li> <li>Concepts: Agents </li> <li>LangGraph: Why LangGraph </li> <li>LangSmith Documentation </li> <li>LangChain Blog </li> <li>LangChain Academy </li> <li>LangChain Resources </li> </ul>"}]}