{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Technical Writing Portfolio","text":"<p>Welcome \u2014 thanks for visiting.</p> <p>This site collects case studies that show how I approach technical writing in practice. Each study walks through a real scenario, combining the problem, the solution, and the documentation choices that tie them together.</p> <p>In the Case Studies section you\u2019ll see examples of how I:</p> <ul> <li>Shape technical material into guidance that readers can actually use  </li> <li>Balance detail with clarity to support different audiences  </li> <li>Build documentation as an integral part of the overall product  </li> </ul>"},{"location":"#about-me","title":"About Me","text":"<p>I\u2019m Will Banks, a technical writer and former research engineer with 10+ years of experience translating complex systems into clear, actionable content. My background spans developer SDKs, APIs, avionics standards, and biomedical platforms \u2014 all unified by one theme: making technical knowledge approachable and useful.</p> <p>I specialize in docs-as-code workflows (AsciiDoc, Markdown, MkDocs, CI/CD pipelines), developer-focused documentation (SDK guides, API references, conceptual explainers), and technical storytelling that connects product features to real-world outcomes.</p> <p>Before pivoting full-time into documentation, I worked on projects ranging from U.S. Navy defense systems to FACE-conformant avionics platforms and Unity-based neuroscience tools. Along the way, I\u2019ve authored comprehensive developer guides, built automated doc pipelines, presented at technical summits, and contributed to peer-reviewed publications.</p> <p>What drives me is clarity: giving engineers, developers, and product teams the confidence to adopt and extend complex technology.</p> <p>Connect with me on LinkedIn for my full background, or check out my Resume</p>"},{"location":"#skills-tools","title":"Skills &amp; Tools","text":"<ul> <li>Tech Writing: CLI &amp; repo workflows, docs-as-code (AsciiDoc, Markdown, PlantUML, Graphviz, OpenAPI, Postman, static site generators like MkDocs and docToolchain), AI-driven workflows</li> <li>Programming &amp; Scripting: Python, C++, Bash, JSON, YAML, Workflow Automation; IDEs including VS Code and IntelliJ IDEA </li> <li>Agile Tools: Jira, Confluence, Git, Teams, Zoom  </li> <li>Operating Systems: Windows &amp; Linux (WSL)  </li> </ul>"},{"location":"#highlights","title":"Highlights","text":"<ul> <li>Authored the FACE Technical Starter Kit Developer\u2019s Guide, distributed across the avionics industry.  </li> <li>Built automated pipelines and docs-as-code workflows from scratch.  </li> <li>Presented product development and documentation at the MOSA Summit and Vanderbilt symposia.  </li> <li>Contributed to multiple peer-reviewed publications across physics and biomedical research.  </li> </ul>"},{"location":"#case-studies-documentation-in-action","title":"Case Studies: Documentation in Action","text":"<p>Each case study demonstrates how I tackle a specific documentation challenge \u2014 whether creating new material, editing existing content, or balancing conceptual depth with practical guidance.</p> <p>Explore the Case Studies \u2192</p>"},{"location":"#lets-connect","title":"Let\u2019s Connect","text":"<p>I\u2019m currently looking for technical writing roles in developer experience, SaaS, or security tooling.  </p> <p>Reach me at your.email@example.com or on LinkedIn.  </p>"},{"location":"about/about/","title":"About the Portfolio","text":"<p>This portfolio serves two purposes: it showcases my writing samples and demonstrates the workflow I use to build and ship documentation.  </p> <p>The site runs on MkDocs with the Material for MkDocs theme and is deployed through GitHub Pages.  All content is written in Markdown, tracked in Git, and published automatically.  Updates follow the same pipeline used on a product team: commits, pull requests, reviews, and continuous deployment.  </p>"},{"location":"case-studies/cnquery-practical-guide_mkdocs/","title":"Getting Started with cnquery: A Practical Guide","text":"<p>Memo on Writing Sample: cnquery Practical Guide</p> <p>This is not official Mondoo documentation.</p> <p>This guide is a demonstration piece created to showcase my technical writing style.  I selected <code>cnquery</code>, an open-source tool from Mondoo, because it is publicly available, technically rich, and well suited to illustrating how I approach developer-facing documentation.</p> <p>I started from Mondoo\u2019s official cnquery documentation and reworked the material into a Practical Guide.  My focus was not only on clear, step-by-step instructions, but also on adding the context that helps readers understand what to do, how to do it, and most importantly, why it matters. Along the way I emphasized:</p> <ul> <li>Scenario-based workflows (for example, checking certificate expiry to prevent downtime)</li> <li>Explanatory bridges that connect technical steps to developer and security outcomes</li> <li>Consistent structure and readability with clear headings, code examples, and outputs</li> <li>Forward-looking context showing how standalone use connects to broader security practices</li> </ul> <p>This guide reflects how I like to approach technical content:</p> <ul> <li>Bringing clarity and depth to material that can otherwise feel reference-heavy</li> <li>Creating resources that support both hands-on adoption and higher-level understanding</li> <li>Structuring content so it\u2019s approachable for newcomers while still valuable for experienced users</li> <li>Thinking \u201cdocs, but beyond docs\u201d \u2014 content that educates, reassures, and helps readers see the bigger picture</li> </ul>"},{"location":"case-studies/cnquery-practical-guide_mkdocs/#getting-started-with-cnquery-a-guided-introduction","title":"Getting Started with cnquery: A Guided Introduction","text":"<p>What if your systems could answer your questions directly? </p> <p>Forget juggling scripts or scrolling through endless logs.  cnquery lets you ask your infrastructure plain questions \u2014 and get clear answers, instantly. It\u2019s part of Mondoo\u2019s mission to make security actionable, approachable, and trustworthy.</p> <p>Who this is for</p> <p>New to Mondoo or cnquery.  Comfortable with a terminal. Want fast, confident answers without reading a full reference.</p> <p>In 10 minutes you\u2019ll:</p> <ul> <li>Install cnquery</li> <li>Run 3 practical queries (OS, TLS expiry, privileged users)</li> <li>Know when to use cnquery vs cnspec</li> <li>See how this scales into the Mondoo Platform</li> </ul>"},{"location":"case-studies/cnquery-practical-guide_mkdocs/#1-what-is-cnquery","title":"1) What is cnquery?","text":"<p>At its core, cnquery is an open source, cloud-native command-line tool powered by MQL (Mondoo Query Language).  It integrates with hundreds of resources so you can ask direct questions about cloud, OS, SaaS, containers, and more.  When you run a query, you point cnquery at a target.  Targets can be your local machine, a remote host over SSH/WinRM, a website for TLS checks, a cloud account, a container, and more. </p> <p>Why this matters</p> <p>Most of us cobble together scripts, grep, and half-remembered commands when problems hit. cnquery gives you one consistent way to interrogate your systems \u2014 without guesswork.</p>"},{"location":"case-studies/cnquery-practical-guide_mkdocs/#2-install-cnquery","title":"2) Install cnquery","text":"<p>Installation scripts come directly from Mondoo\u2019s distribution.  In most environments they can be run as-is; for stricter environments see Provider Management.</p> <p>Linux &amp; macOS (curl script):</p> <pre><code>bash -c \"$(curl -sSL https://install.mondoo.com/sh)\"\n</code></pre> <p>Windows (PowerShell):</p> <pre><code>Set-ExecutionPolicy Unrestricted -Scope Process -Force\n[System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072\niex ((New-Object System.Net.WebClient).DownloadString('https://install.mondoo.com/ps1/cnquery'))\nInstall-Mondoo -Product cnquery\n</code></pre> <p>Verify installation:</p> <pre><code>cnquery version\n</code></pre> <p>Expected output:</p> <pre><code>cnquery vX.Y.Z #e.g. v8.3.0\n</code></pre>"},{"location":"case-studies/cnquery-practical-guide_mkdocs/#3-your-first-queries","title":"3) Your first queries","text":"<p>You can run one-off queries or use the interactive shell.  One-off mode is perfect for quick checks you might script into automation, while the interactive shell is best for exploring resources and learning the language.</p> <p>In these examples we use the local target (your current machine). Other common targets include <code>ssh user@host</code>, <code>host mondoo.com</code>, <code>docker</code>, <code>k8s</code>, and cloud providers like <code>aws</code>.</p> <p>Common Targets</p> <ul> <li><code>local</code> \u2192 your current machine</li> <li><code>ssh user@host</code> \u2192 remote Linux/Windows hosts</li> <li><code>host &lt;domain&gt;</code> \u2192 websites (for TLS checks)</li> <li><code>docker</code>, <code>k8s</code> \u2192 containers and clusters</li> <li><code>aws</code>, <code>gcp</code>, <code>azure</code> \u2192 cloud accounts</li> </ul> <p>See full list in Supported Query Targets.</p> <p>Option A \u2014 one-off:</p> <pre><code>cnquery run local -c \"os.name\"\n</code></pre> <p>Option B \u2014 shell (recommended for exploring):</p> <pre><code>cnquery shell local\nhelp os\n</code></pre> <p>Then run queries like <code>os.name</code>.</p> <p>Why this matters</p> <p>cnquery gives you two ways to work: fast one-off commands that you can drop into scripts, or a dedicated shell for exploration.  This flexibility means you can start small and scale up as your needs grow, without changing tools.</p>"},{"location":"case-studies/cnquery-practical-guide_mkdocs/#example-1-what-os-am-i-running","title":"Example 1 \u2014 \u201cWhat OS am I running?\u201d","text":"<pre><code>cnquery run local -c \"os.name\"\n</code></pre> <p>Output (example):</p> <pre><code>Ubuntu\n</code></pre> <p><code>os.name</code> is provided by the OS pack.</p> <p>Why this matters</p> <p>Sometimes the simplest question is the most important.  Whether you\u2019re jumping between development, staging, and production machines or auditing servers you haven\u2019t touched in months, this query gives you a consistent way to confirm exactly what system you\u2019re on.  No need to recall which platform uses <code>uname</code> or <code>lsb_release</code> \u2014 cnquery provides one universal approach.</p>"},{"location":"case-studies/cnquery-practical-guide_mkdocs/#example-2-are-my-tls-certs-about-to-expire","title":"Example 2 \u2014 \u201cAre my TLS certs about to expire?\u201d","text":"<p>Check a public host\u2019s certificates (30-day horizon):</p> <pre><code>cnquery shell host mondoo.com\ntls.certificates.where(notAfter - time.now &lt; 30 * time.day) { subject.dn issuer.dn notAfter }\n</code></pre> <ul> <li><code>host mondoo.com</code> targets a website (SSL/TLS).  </li> <li><code>notAfter</code> is the certificate expiry field; we compare it with <code>time.now</code>.</li> </ul> <p>Why this matters</p> <p>Few issues cause more disruption than an expired TLS certificate.  Customers see a browser warning, trust drops, and your team is forced into emergency response.  This query helps you stay ahead by flagging certificates that are close to expiring, giving you time to renew.</p>"},{"location":"case-studies/cnquery-practical-guide_mkdocs/#example-3-who-has-sudo-access","title":"Example 3 \u2014 \u201cWho has sudo access?\u201d","text":"<p>On many Linux distros, privileged users belong to the <code>sudo</code> group:</p> <pre><code>cnquery run local -c 'group(\"sudo\") { members { name } }'\n</code></pre> <p>This directly queries the <code>group</code> resource, then lists its <code>members</code>. Swap <code>sudo \u2192 wheel</code> (RHEL/Fedora) or <code>Administrators</code> (Windows).</p> <p>Why this matters</p> <p>Privilege management is a foundation of security.  A single unexpected user with administrator rights can open the door to major risk.  This query gives you immediate visibility into who holds elevated access, so you can validate against your intended policy without manual parsing.</p>"},{"location":"case-studies/cnquery-practical-guide_mkdocs/#4-real-world-scenario-responding-to-a-cve","title":"4) Real-world scenario: Responding to a CVE","text":"<p>A CVE affecting <code>openssl</code> just dropped. Find impacted hosts fast:</p> <pre><code>cnquery run local -c \"packages.where(name == 'openssl') { name version }\"\n</code></pre> <p><code>packages</code> is the list of OS packages. Each <code>package</code> contains fields like <code>name</code> and <code>version</code>.</p> <p>Why this matters</p> <p>When a new vulnerability is announced, speed matters.  You need to know immediately which of your systems are running affected versions.  cnquery lets you search installed packages in seconds, giving you clear visibility and the confidence to prioritize patching quickly \u2014 without assembling ad-hoc scripts under pressure.</p>"},{"location":"case-studies/cnquery-practical-guide_mkdocs/#5-where-cnquery-fits-with-the-mondoo-platform","title":"5) Where cnquery fits with the Mondoo Platform","text":"<p>By itself, cnquery gives you instant answers.  But its real power is as a springboard into automation:</p> <ul> <li>Feed results into cnspec for repeatable compliance checks  </li> <li>Pipe data into the Mondoo Platform to visualize risks across fleets  </li> <li>Turn one-off discoveries (like that expiring cert) into policies that prevent recurrence</li> </ul> <p>Why this matters</p> <p>cnquery is more than a standalone tool \u2014 it\u2019s the entry point into Mondoo\u2019s larger ecosystem. The same queries you run today can evolve into policies, dashboards, and automated workflows tomorrow. You gain immediate visibility while building toward scalable, repeatable security practices.</p>"},{"location":"case-studies/cnquery-practical-guide_mkdocs/#6-faq","title":"6) FAQ","text":"<p>When should I use <code>cnquery</code> vs <code>cnspec</code>?</p> <p>Use cnquery to ask questions and explore with ad\u2011hoc MQL.  Use cnspec when you want repeatable policy checks (benchmarks, remediations, CI/CD gates).  See examples throughout the cnspec docs</p> <p>Do I need to specify a \u201ctarget\u201d?</p> <p>Yes.  Common ones are <code>local</code>, <code>ssh user@host</code>, <code>host &lt;domain&gt;</code>, cloud providers like <code>aws</code>, and many more\u2014see the Supported Query Targets page for examples.  See the full list in Supported Query Targets.</p> <p>Is cnquery safe in production?</p> <p>cnquery queries configuration/state; it doesn\u2019t alter your workloads.  It may write provider plugins unless you disable auto\u2011update; for strict read\u2011only environments, pre\u2011install providers and turn off provider auto\u2011update.</p>"},{"location":"case-studies/cnquery-practical-guide_mkdocs/#7-where-to-go-next","title":"7) Where to go next","text":"<ul> <li>Learn MQL basics and write effective MQL.</li> <li>Explore Query Your Infrastructure and the MQL Resource Reference.</li> <li>When you\u2019re ready for policy\u2011as\u2011code and continuous assessment, move to cnspec and the Mondoo Platform.</li> </ul>"},{"location":"case-studies/horizon3ai-tripwires-redline/","title":"NodeZero Tripwires Redline Case Study","text":"<p>About this case study</p> <p>This is not official Horizon3.ai documentation.  </p> <p>This exercise shows my approach to improving an existing documentation page. Rather than rewriting from scratch, I created an editorial redline in Google Docs to highlight opportunities to enhance clarity, structure, and consistency.</p> <p>\ud83d\udc49 View the redlined document in Google Docs </p>"},{"location":"case-studies/horizon3ai-tripwires-redline/#my-editorial-approach","title":"My Editorial Approach","text":"<p>I reviewed the NodeZero Tripwires documentation for both macro-level structure and micro-level style issues. Some of the key areas I addressed:</p> <ul> <li>Structure &amp; Navigation: Break long lists into tabs/accordions, add troubleshooting anchors, and flowcharts.  </li> <li>Consistency: Standardize admonitions, hyperlink style, and UI element formatting.  </li> <li>Voice &amp; Style: Shift to active voice, rewrite fragments, and align terminology with branding.  </li> <li>Audience: Reduce jargon, make prerequisites explicit, and emphasize actionable instructions.  </li> </ul> <p>This exercise demonstrates my ability to:</p> <ul> <li>Evaluate documentation critically.  </li> <li>Apply consistent editorial standards.  </li> <li>Improve usability while respecting technical accuracy.  </li> </ul>"},{"location":"case-studies/longchain-chains-vs-agents/","title":"Chains vs. Agents in LangChain","text":"<p>About this case study</p> <p>This is not official LangChain documentation.  </p> <p>This is a demonstration sample created for my portfolio. It explains a core LangChain concept \u2014 Chains vs. Agents \u2014 in a clear, approachable way.  </p> <p>Claims and definitions are aligned to the latest LangChain &amp; LangGraph docs (v0.2). LangChain Introduction | Concepts: Agents | LangGraph: Why LangGraph | LangSmith Docs</p>"},{"location":"case-studies/longchain-chains-vs-agents/#welcome-why-you-should-care","title":"Welcome: Why You Should Care","text":"<p>If you\u2019re new to LangChain, you\u2019ve probably run into two terms right away: Chain and Agent.  Both are central concepts, and both are powerful \u2014 but they serve different purposes.</p> <p>Why does this matter? </p> <ul> <li>Using a Chain where you actually need an Agent can leave you with workflows that feel rigid and difficult to adapt.  </li> <li>Using an Agent where a Chain would suffice can lead to unnecessary overhead: slower runs, higher API costs, and trickier debugging.  </li> </ul> <p>Developers often encounter these pain points firsthand:  </p> <ul> <li>Chains that break because they can\u2019t handle a new condition.  </li> <li>Agents that wander off-course, loop endlessly, or generate a surprising number of tool calls.  </li> </ul> <p>This guide gives you the mental model you need \u2014 no prior LangChain experience required.  By the end, you\u2019ll understand:</p> <ul> <li>What a Chain is (and why it\u2019s like following a recipe).  </li> <li>What an Agent is (and why it\u2019s like a chef improvising in the kitchen).  </li> <li>How to decide between them for your project.  </li> <li>Common pitfalls and best practices.  </li> <li>How they fit into the broader LangChain ecosystem: LangGraph (for controllable, stateful agents and workflows) and LangSmith (for tracing, evaluating, and monitoring).</li> </ul> <p>In the sections that follow, we\u2019ll compare Chains and Agents side by side, highlight use cases, share diagrams, and show how these concepts connect to the modern LangChain stack.</p>"},{"location":"case-studies/longchain-chains-vs-agents/#chains-vs-agents-picture-it","title":"Chains vs. Agents: Picture It","text":"<p>Before diving into details, here\u2019s the high-level contrast.  Chains and Agents are both ways of structuring work with an LLM \u2014 but they think differently about control.</p> <pre><code>graph LR\n    I[Input] --&gt; S1[Step 1]\n    S1 --&gt; S2[Step 2]\n    S2 --&gt; SN[... Step n]\n    SN --&gt; O[Output]</code></pre> <p>Figure 1: A Chain is a fixed pipeline. </p> <p>Input flows through predefined steps you design in advance, producing a predictable output.</p> <pre><code>graph TD\n    U[User Task] --&gt; C((LLM Controller))\n    C --&gt; T1[Tool A]\n    C --&gt; T2[Tool B]\n    C --&gt; T3[Tool C]\n    T1 --&gt; O1[Observation]\n    T2 --&gt; O2[Observation]\n    T3 --&gt; O3[Observation]\n    O1 --&gt; C\n    O2 --&gt; C\n    O3 --&gt; C\n    C --&gt; OUT[Final Answer]</code></pre> <p>Figure 2: An Agent is an improviser. </p> <p>The LLM chooses tools at runtime, reasons over observations, and iterates until it can deliver an answer.</p>"},{"location":"case-studies/longchain-chains-vs-agents/#chains-the-recipe-approach","title":"Chains: The \u201cRecipe\u201d Approach","text":""},{"location":"case-studies/longchain-chains-vs-agents/#what-it-feels-like","title":"What it feels like","text":"<ul> <li>You wire together components (prompting, retrieval, parsing, post-processing).  </li> <li>The flow is predictable and repeatable (easier to debug, easier to test).  </li> <li>Ideal for document pipelines, summarization, and data transforms.  </li> </ul> <p>Realistic use case: </p> <p>A support team wants daily digests of customer tickets.  A Chain can summarize each ticket, extract key issues, and compile them into a single report.</p> <p>When to use Chains</p> <p>Use a Chain when your steps are known in advance and you want predictability. Think repeatable workflows: ETL, summarization, and document processing.</p>"},{"location":"case-studies/longchain-chains-vs-agents/#agents-the-improviser","title":"Agents: The \u201cImproviser\u201d","text":"<p>An Agent is a system that uses an LLM to decide what to do next.  Instead of you hard-coding each step, the model chooses which tools or actions to run at runtime based on the task and observed tool outputs.</p>"},{"location":"case-studies/longchain-chains-vs-agents/#what-it-feels-like_1","title":"What it feels like","text":"<ul> <li>You define tools (web search, math, database lookups, APIs).  </li> <li>The LLM is the controller that decides which tool to use, in what order.  </li> <li>Ideal for interactive research assistants, multi-tool orchestration, or tasks where the path isn\u2019t clear upfront.  </li> </ul> <p>Realistic use case: </p> <p>A research assistant that decides when to search the web, when to use a calculator, and when to summarize findings \u2014 depending on the query.</p> <p>Modern guidance: </p> <p>LangChain explicitly recommends building agents with LangGraph for control, reliability, and production readiness.  Legacy <code>AgentExecutor</code> is being phased out.</p> <p>When to use Agents</p> <p>Use an Agent when you need dynamic tool use and the steps can\u2019t be pre-defined. Expect more variability and overhead, and plan on adding observability (LangSmith) and guardrails.</p>"},{"location":"case-studies/longchain-chains-vs-agents/#side-by-side-chains-vs-agents","title":"Side-by-Side: Chains vs. Agents","text":"Aspect Chains (Recipe) Agents (Improviser) Flow Fixed, pre-defined sequence Dynamic; LLM chooses tools/steps at runtime Predictability High (repeatable, testable) Lower (varies with inputs, tool outcomes, model decisions) Use cases Summarization pipelines, ETL/data transforms Research assistants, tool orchestration, conditional flows Debugging Easier: clear steps Harder: LLM\u2019s choices + external tools Performance/Cost Lower latency, more efficient Higher overhead, longer latency"},{"location":"case-studies/longchain-chains-vs-agents/#decision-helper","title":"Decision Helper","text":"<pre><code>graph TD\n    Q{\"Do you know the steps ahead of time?\"}\n    Q --&gt;|Yes| C[\"Use a Chain\"]\n    Q --&gt;|No| A[\"Use an Agent (via LangGraph)\"]</code></pre> <p>Figure 3: If you know the steps ahead of time, use a Chain.</p> <p>If not, use an Agent \u2014 and for production, build it with LangGraph for controllability and persistence.</p>"},{"location":"case-studies/longchain-chains-vs-agents/#common-pitfalls","title":"Common Pitfalls","text":"Paradigm Pitfall Fix Chains Brittle if a step expects perfectly formatted input Validate and normalize inputs early; keep steps small and composable Agents LLM chooses the wrong tool or loops Limit toolset initially, set iteration/time limits, and add observability <p>Comfort check: </p> <p>It\u2019s normal if your first Agent feels chaotic.  Start small, grow toolsets gradually, and trace runs to understand decisions.</p>"},{"location":"case-studies/longchain-chains-vs-agents/#best-practices","title":"Best Practices","text":"<ul> <li>Start simple: Begin with Chains; graduate to Agents only when necessary.  </li> <li>Keep it modular: Break big tasks into smaller Chains, then combine.  </li> <li>Limit toolsets: The fewer tools an Agent can choose from, the more reliable it is.  </li> <li>Trace everything: Use LangSmith to see what\u2019s happening under the hood.  </li> <li>Plan for control: Use LangGraph to structure Agents for production.  </li> </ul>"},{"location":"case-studies/longchain-chains-vs-agents/#where-chains-agents-fit-in-the-langchain-ecosystem","title":"Where Chains &amp; Agents Fit in the LangChain Ecosystem","text":"<pre><code>graph TB\n    A[\"LangChain: Building blocks (models, retrievers, tools)\"] --&gt; B[\"LangGraph: Orchestration(stateful agents, workflows)\"]\n    B --&gt; C[\"LangSmith: Observability (tracing, evaluation, monitoring)\"]</code></pre> <ul> <li>LangChain gives you the components and mental model.  </li> <li>LangGraph is the recommended framework for building controllable, stateful agents and workflows.  </li> <li>LangSmith is the observability + evaluation layer to trace, measure, and ship with confidence.  </li> </ul> <p>Together, they form the modern LangChain stack: build, orchestrate, observe.</p>"},{"location":"case-studies/longchain-chains-vs-agents/#wrap-up-next-steps","title":"Wrap-Up &amp; Next Steps","text":"<p>You now have the mental model:</p> <ul> <li>Chains = the predictable recipe.  </li> <li>Agents = the improviser that picks tools dynamically (best built with LangGraph today).  </li> </ul> <p>Try this yourself:</p> <ol> <li>Build a Chain that summarizes a paragraph and extracts two facts.  </li> <li>Build an Agent that can either search the web or do simple math.     Trace the run in LangSmith to watch its decisions.  </li> </ol> <p>By now, Chains vs. Agents should feel less like jargon and more like clear tools in your kit.  You\u2019re ready to choose the right one with confidence\u2014and you\u2019ve got the ecosystem pieces (LangGraph + LangSmith) to grow from demo to production.</p> <p>\ud83d\udc4f That\u2019s it! You\u2019re ready to put Chains and Agents to work.</p>"},{"location":"case-studies/longchain-chains-vs-agents/#resources","title":"Resources","text":"<ul> <li>LangChain Introduction </li> <li>Concepts: Agents </li> <li>LangGraph: Why LangGraph </li> <li>LangSmith Documentation </li> <li>LangChain Blog </li> <li>LangChain Academy </li> <li>LangChain Resources </li> </ul>"},{"location":"samples/cli-reference-sample/","title":"CLI Reference (Sample)","text":"<p>Short, scannable reference entries.</p>"},{"location":"samples/cli-reference-sample/#acme-login","title":"<code>acme login</code>","text":"<p>Synopsis: Authenticate to Acme Cloud.</p> <pre><code>acme login [--token TOKEN] [--profile NAME]\n</code></pre> <p>Options - <code>--token</code> string. Personal access token. - <code>--profile</code> string. Named profile to update.</p>"},{"location":"samples/cli-reference-sample/#acme-deploy","title":"<code>acme deploy</code>","text":"<p>Synopsis: Deploy a service.</p> <pre><code>acme deploy --service NAME [--env prod|staging] [--wait]\n</code></pre> <p>Options - <code>--service</code> string. Required. - <code>--env</code> enum. Default <code>staging</code>. - <code>--wait</code> flag. Block until rollout completes.</p>"},{"location":"samples/how-to-deploy-flask-on-docker/","title":"Deploy a Flask App in Docker","text":"<p>Note</p> <p>Sample how-to. Short, task-focused, and testable.</p>"},{"location":"samples/how-to-deploy-flask-on-docker/#prerequisites","title":"Prerequisites","text":"<ul> <li>Docker installed</li> <li>Python 3.9+</li> </ul>"},{"location":"samples/how-to-deploy-flask-on-docker/#steps","title":"Steps","text":"<ol> <li>Create files:     <pre><code>mkdir flask-docker &amp;&amp; cd flask-docker\necho \"from flask import Flask; app = Flask(__name__); @app.get('/')\\ndef home(): return 'Hello, Docker!'\" &gt; app.py\necho \"Flask==3.0.0\" &gt; requirements.txt\n</code></pre></li> <li>Add a <code>Dockerfile</code>:     <pre><code>FROM python:3.12-slim\nWORKDIR /app\nCOPY requirements.txt .\nRUN pip install -r requirements.txt\nCOPY . .\nEXPOSE 5000\nCMD [\"python\", \"app.py\"]\n</code></pre></li> <li>Build and run:     <pre><code>docker build -t flask-demo .\ndocker run -p 5000:5000 flask-demo\n</code></pre></li> <li>Visit <code>http://localhost:5000</code></li> </ol>"},{"location":"samples/how-to-deploy-flask-on-docker/#troubleshooting","title":"Troubleshooting","text":"<ul> <li>If the container exits, check logs:     <pre><code>docker logs &lt;container_id&gt;\n</code></pre></li> </ul>"},{"location":"samples/understanding-rbac/","title":"Understanding RBAC","text":"<p>Role-Based Access Control (RBAC) assigns permissions to roles, not individuals. Users inherit permissions by the roles they hold.</p>"},{"location":"samples/understanding-rbac/#why-it-matters","title":"Why it matters","text":"<ul> <li>Reduces permission sprawl</li> <li>Centralizes policy changes</li> <li>Auditable and easier to reason about</li> </ul>"},{"location":"samples/understanding-rbac/#core-concepts","title":"Core concepts","text":"<ul> <li>User: an identity</li> <li>Role: a named set of permissions</li> <li>Permission: an allowed action on a resource</li> <li>Assignment: user \u2194 role mapping</li> </ul>"},{"location":"samples/understanding-rbac/#common-pitfalls","title":"Common pitfalls","text":"<ul> <li>Too many bespoke roles</li> <li>Granting roles directly to service accounts without review</li> </ul>"}]}